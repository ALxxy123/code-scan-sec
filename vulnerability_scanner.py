"""
Advanced Vulnerability Scanner Module.

This module provides comprehensive security vulnerability detection
based on OWASP Top 10 and CWE categories.
"""

from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import re
import yaml
from logger import get_logger

logger = get_logger()


@dataclass
class Vulnerability:
    """Represents a detected security vulnerability."""
    name: str
    severity: str  # critical, high, medium, low, info
    cwe: str
    owasp: str
    pattern: str
    description: str
    recommendation: str
    file_path: str
    line_number: int
    matched_text: str
    category: str
    languages: List[str]

    def to_dict(self) -> Dict:
        """Convert vulnerability to dictionary."""
        return {
            'name': self.name,
            'severity': self.severity,
            'cwe': self.cwe,
            'owasp': self.owasp,
            'description': self.description,
            'recommendation': self.recommendation,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'matched_text': self.matched_text,
            'category': self.category
        }

    @property
    def severity_score(self) -> int:
        """Get numeric severity score for sorting."""
        scores = {
            'critical': 5,
            'high': 4,
            'medium': 3,
            'low': 2,
            'info': 1
        }
        return scores.get(self.severity.lower(), 0)


class VulnerabilityScanner:
    """
    Advanced vulnerability scanner for security issues.

    Detects various security vulnerabilities based on pattern matching
    and static analysis techniques.
    """

    def __init__(self, rules_file: str = "vulnerability_rules.yaml"):
        """
        Initialize vulnerability scanner.

        Args:
            rules_file: Path to vulnerability rules YAML file
        """
        self.rules_file = rules_file
        self.rules = self._load_rules()
        logger.info(f"Loaded {len(self.rules)} vulnerability categories")

    def _load_rules(self) -> Dict:
        """
        Load vulnerability detection rules from YAML file.

        Returns:
            Dict: Vulnerability rules organized by category

        Raises:
            FileNotFoundError: If rules file doesn't exist
            yaml.YAMLError: If rules file is invalid
        """
        rules_path = Path(self.rules_file)

        if not rules_path.exists():
            logger.warning(f"Vulnerability rules file not found: {self.rules_file}")
            return {}

        try:
            with open(rules_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
                return data.get('vulnerabilities', {})
        except yaml.YAMLError as e:
            logger.error(f"Failed to parse vulnerability rules: {e}")
            return {}
        except Exception as e:
            logger.error(f"Error loading vulnerability rules: {e}")
            return {}

    def _get_language_from_extension(self, file_path: str) -> str:
        """
        Determine programming language from file extension.

        Args:
            file_path: Path to the file

        Returns:
            str: Language identifier
        """
        extension_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript',
            '.jsx': 'jsx',
            '.tsx': 'tsx',
            '.php': 'php',
            '.java': 'java',
            '.go': 'go',
            '.rb': 'ruby',
            '.cs': 'csharp',
            '.cpp': 'cpp',
            '.c': 'c',
            '.sh': 'bash',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.json': 'json',
            '.xml': 'xml',
            '.sql': 'sql'
        }

        ext = Path(file_path).suffix.lower()
        return extension_map.get(ext, 'unknown')

    def _matches_language(self, rule_languages: List[str], file_language: str) -> bool:
        """
        Check if rule applies to file language.

        Args:
            rule_languages: Languages the rule applies to
            file_language: Language of the file being scanned

        Returns:
            bool: True if rule applies to this language
        """
        if not rule_languages or 'all' in rule_languages:
            return True
        return file_language in rule_languages

    def scan_file(self, file_path: str, content: Optional[str] = None) -> List[Vulnerability]:
        """
        Scan a file for security vulnerabilities.

        Args:
            file_path: Path to the file to scan
            content: Optional file content (if already read)

        Returns:
            List[Vulnerability]: List of detected vulnerabilities
        """
        vulnerabilities = []

        # Read file content if not provided
        if content is None:
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
            except Exception as e:
                logger.error(f"Failed to read file {file_path}: {e}")
                return vulnerabilities

        # Get file language
        file_language = self._get_language_from_extension(file_path)
        logger.debug(f"Scanning {file_path} as {file_language}")

        # Split content into lines for line number tracking
        lines = content.split('\n')

        # Scan for each vulnerability category
        for category, rules in self.rules.items():
            if not rules:
                continue

            for rule in rules:
                # Check if rule applies to this language
                rule_languages = rule.get('languages', ['all'])
                if not self._matches_language(rule_languages, file_language):
                    continue

                pattern = rule.get('pattern', '')
                if not pattern:
                    continue

                try:
                    # Compile regex pattern
                    regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)

                    # Search for pattern in each line
                    for line_num, line in enumerate(lines, start=1):
                        matches = regex.finditer(line)

                        for match in matches:
                            vuln = Vulnerability(
                                name=rule.get('name', 'Unknown Vulnerability'),
                                severity=rule.get('severity', 'medium'),
                                cwe=rule.get('cwe', 'Unknown'),
                                owasp=rule.get('owasp', 'Unknown'),
                                pattern=pattern,
                                description=rule.get('description', ''),
                                recommendation=rule.get('recommendation', ''),
                                file_path=file_path,
                                line_number=line_num,
                                matched_text=match.group(0)[:100],  # Limit to 100 chars
                                category=category,
                                languages=rule_languages
                            )
                            vulnerabilities.append(vuln)
                            logger.debug(
                                f"Found {vuln.severity} vulnerability: {vuln.name} "
                                f"at {file_path}:{line_num}"
                            )

                except re.error as e:
                    logger.warning(f"Invalid regex pattern in rule '{rule.get('name')}': {e}")
                except Exception as e:
                    logger.error(f"Error scanning with rule '{rule.get('name')}': {e}")

        return vulnerabilities

    def scan_directory(
        self,
        directory: str,
        extensions: Optional[List[str]] = None,
        ignore_patterns: Optional[List[str]] = None
    ) -> List[Vulnerability]:
        """
        Scan entire directory for vulnerabilities.

        Args:
            directory: Directory path to scan
            extensions: File extensions to scan (default: common code files)
            ignore_patterns: Patterns to ignore (glob patterns)

        Returns:
            List[Vulnerability]: All detected vulnerabilities
        """
        if extensions is None:
            extensions = [
                '.py', '.js', '.ts', '.jsx', '.tsx', '.php', '.java',
                '.go', '.rb', '.cs', '.cpp', '.c', '.sh'
            ]

        if ignore_patterns is None:
            ignore_patterns = [
                '**/node_modules/**', '**/.git/**', '**/venv/**',
                '**/__pycache__/**', '**/dist/**', '**/build/**'
            ]

        all_vulnerabilities = []
        dir_path = Path(directory)

        if not dir_path.exists():
            logger.error(f"Directory does not exist: {directory}")
            return all_vulnerabilities

        # Scan all files with matching extensions
        for ext in extensions:
            pattern = f"**/*{ext}"
            for file_path in dir_path.glob(pattern):
                # Check if file matches ignore patterns
                should_ignore = False
                for ignore in ignore_patterns:
                    if file_path.match(ignore):
                        should_ignore = True
                        break

                if should_ignore:
                    continue

                logger.info(f"Scanning file: {file_path}")
                vulns = self.scan_file(str(file_path))
                all_vulnerabilities.extend(vulns)

        return all_vulnerabilities

    def get_statistics(self, vulnerabilities: List[Vulnerability]) -> Dict:
        """
        Get statistics about detected vulnerabilities.

        Args:
            vulnerabilities: List of vulnerabilities

        Returns:
            Dict: Statistics including counts by severity, category, etc.
        """
        stats = {
            'total': len(vulnerabilities),
            'by_severity': {},
            'by_category': {},
            'by_cwe': {},
            'by_owasp': {},
            'critical_and_high': 0
        }

        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln.severity
            stats['by_severity'][severity] = stats['by_severity'].get(severity, 0) + 1

            # Count by category
            category = vuln.category
            stats['by_category'][category] = stats['by_category'].get(category, 0) + 1

            # Count by CWE
            cwe = vuln.cwe
            stats['by_cwe'][cwe] = stats['by_cwe'].get(cwe, 0) + 1

            # Count by OWASP
            owasp = vuln.owasp
            stats['by_owasp'][owasp] = stats['by_owasp'].get(owasp, 0) + 1

            # Count critical and high
            if severity.lower() in ['critical', 'high']:
                stats['critical_and_high'] += 1

        return stats

    def filter_by_severity(
        self,
        vulnerabilities: List[Vulnerability],
        min_severity: str = 'low'
    ) -> List[Vulnerability]:
        """
        Filter vulnerabilities by minimum severity level.

        Args:
            vulnerabilities: List of vulnerabilities
            min_severity: Minimum severity (critical, high, medium, low, info)

        Returns:
            List[Vulnerability]: Filtered vulnerabilities
        """
        severity_order = {
            'critical': 5,
            'high': 4,
            'medium': 3,
            'low': 2,
            'info': 1
        }

        min_score = severity_order.get(min_severity.lower(), 0)
        return [v for v in vulnerabilities if v.severity_score >= min_score]

    def sort_by_severity(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """
        Sort vulnerabilities by severity (critical first).

        Args:
            vulnerabilities: List of vulnerabilities

        Returns:
            List[Vulnerability]: Sorted vulnerabilities
        """
        return sorted(vulnerabilities, key=lambda v: v.severity_score, reverse=True)


def scan_for_vulnerabilities(
    path: str,
    rules_file: str = "vulnerability_rules.yaml",
    min_severity: str = "low"
) -> Tuple[List[Vulnerability], Dict]:
    """
    Convenience function to scan for vulnerabilities.

    Args:
        path: File or directory path to scan
        rules_file: Path to vulnerability rules file
        min_severity: Minimum severity level to report

    Returns:
        Tuple[List[Vulnerability], Dict]: Vulnerabilities and statistics
    """
    scanner = VulnerabilityScanner(rules_file)
    path_obj = Path(path)

    if path_obj.is_file():
        vulnerabilities = scanner.scan_file(str(path_obj))
    elif path_obj.is_dir():
        vulnerabilities = scanner.scan_directory(str(path_obj))
    else:
        logger.error(f"Invalid path: {path}")
        return [], {}

    # Filter by severity
    vulnerabilities = scanner.filter_by_severity(vulnerabilities, min_severity)

    # Sort by severity
    vulnerabilities = scanner.sort_by_severity(vulnerabilities)

    # Get statistics
    stats = scanner.get_statistics(vulnerabilities)

    return vulnerabilities, stats
